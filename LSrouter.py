####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json

class LSA:
    def __init__(self, advertising_router, seq_num):
        self.advertising_router = advertising_router
        self.seq_num = seq_num
        # Chắc phải sửa key thành router1_id và router2_id {routerId: [Cost, Port]}
        self.links = {}
    
    def to_json(self):
        return json.dumps({
            "advertising_router": self.advertising_router,
            "seq_num": self.seq_num,
            "links": self.links
        })

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.routing_table = {}
        # Cấu trúc của LSDB sẽ như này
        # Key sẽ là advertising_router_addr
        # Value sẽ là tuple (endpoint, cost, port)
        # T nghĩ nó sẽ giống danh sách cạnh nên implement như này
        self.link_state_db = {}
        self.seq_lsa = {}
        self.link_state_db[self.addr] = []
        self.lsa = LSA(self.addr, 0)
        pass

    def convert_json_to_lsa(self, str):
        data = json.loads(str)
        lsa = LSA(
            data["advertising_router"],
            data["seq_num"],
        )
        lsa.links = data["links"]
        return lsa
    
    def broadcast(self, packet, sender_router_addr):
        for neighbor_port, link in self.links.items():  
            if link.e1.isupper() and link.e2.isupper() and link.e1 != sender_router_addr and link.e2 != sender_router_addr:
                self.send(neighbor_port, packet)

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            recv_lsa = self.convert_json_to_lsa(packet.content)
            # Kiểm tra seq_num
            if (recv_lsa.advertising_router in self.seq_lsa and recv_lsa.seq_num < self.seq_lsa[recv_lsa.advertising_router]):
                pass
            self.seq_lsa[recv_lsa.advertising_router] = recv_lsa.seq_num

            # Này là để update vào LSDB mà có vẻ như nó đang update lặp, chưa handle sẽ sửa sau
            for endpoint, links in recv_lsa.links.items():
                if recv_lsa.advertising_router not in self.link_state_db:
                    self.link_state_db[recv_lsa.advertising_router] = []
                self.link_state_db[recv_lsa.advertising_router].append((endpoint, links[0], links[1]))

            self.broadcast(packet, packet.src_addr)
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.lsa.links[endpoint] = [cost, port]
        self.link_state_db[self.addr].append((endpoint, cost, port))
        packet = Packet(Packet.ROUTING, self.addr, endpoint, self.lsa.to_json())
        self.broadcast(packet, "")
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSDB: {self.link_state_db}"
