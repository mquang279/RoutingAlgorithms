####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import json
import heapq

class LSA:
    def __init__(self, advertising_router, seq_num):
        self.advertising_router = advertising_router
        self.seq_num = seq_num
        self.links = {}
    
    def to_json(self):
        return json.dumps({
            "advertising_router": self.advertising_router,
            "seq_num": self.seq_num,
            "links": self.links
        })

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """    
    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.routing_table = {}
        # Cấu trúc của LSDB sẽ như này
        # Key sẽ là advertising_router_addr
        # Value sẽ là tuple (endpoint, cost, port)
        # T nghĩ nó sẽ giống danh sách cạnh nên implement như này
        self.link_state_db = {}
        self.seq_lsa = {}
        self.link_state_db[self.addr] = []
        self.lsa = LSA(self.addr, 0)
        self.routing_table = {}
        
    def config_routing_table(self):
        pq = []
        heapq.heappush(pq, (0, (self.addr, self.addr)))
        visited = set()
        parent = {}
        dist = {}
        while pq:
            tmp = heapq.heappop(pq)
            curr_addr = tmp[1][0]
            curr_cost = tmp[0]
            curr_parrent = tmp[1][1]
            if curr_addr not in visited:
                visited.add(curr_addr)
                dist[curr_addr] = curr_cost
                parent[curr_addr] = curr_parrent
                if (curr_addr in self.link_state_db):
                    for edge in self.link_state_db[curr_addr]:
                        heapq.heappush(pq, (curr_cost + edge[1], (edge[0], curr_addr)))
                        
        self.routing_table = {}
        for router_addr in visited:
            if router_addr == self.addr:
                continue
            next_hop = router_addr
            while parent[next_hop] != self.addr:
                next_hop = parent[next_hop]
            if next_hop in self.lsa.links:
                self.routing_table[router_addr] = self.lsa.links[next_hop][1]

    def convert_json_to_lsa(self, str):
        data = json.loads(str)
        lsa = LSA(
            data["advertising_router"],
            data["seq_num"],
        )
        lsa.links = data["links"]
        return lsa
    
    def broadcast(self, sender_router_addr):
        for port, link in self.links.items():  
            if link.e1.isupper() and link.e2.isupper() and link.e1 != sender_router_addr and link.e2 != sender_router_addr:
                packet = None
                if link.e1 != self.addr:
                    packet = Packet(Packet.ROUTING, self.addr, link.e1, self.lsa.to_json())
                else:
                    packet = Packet(Packet.ROUTING, self.addr, link.e2, self.lsa.to_json())
                self.send(port, packet)
        self.lsa.seq_num = self.lsa.seq_num + 1

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if (packet.dst_addr in self.routing_table):
                self.send(self.routing_table[packet.dst_addr], packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            recv_lsa = self.convert_json_to_lsa(packet.content)
            # Kiểm tra seq_num
            if (recv_lsa.advertising_router in self.seq_lsa and recv_lsa.seq_num <= self.seq_lsa[recv_lsa.advertising_router]):
                return
            self.seq_lsa[recv_lsa.advertising_router] = recv_lsa.seq_num

            # Này là để update vào LSDB mà có vẻ như nó đang update lặp, chưa handle sẽ sửa sau
            for endpoint, links in recv_lsa.links.items():
                if recv_lsa.advertising_router not in self.link_state_db:
                    self.link_state_db[recv_lsa.advertising_router] = []
                self.link_state_db[recv_lsa.advertising_router].append((endpoint, links[0], links[1]))
            self.link_state_db[recv_lsa.advertising_router] = list(set(self.link_state_db[recv_lsa.advertising_router]))
            self.broadcast(packet.src_addr)
            self.config_routing_table()
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.lsa.links[endpoint] = [cost, port]
        self.link_state_db[self.addr].append((endpoint, cost, port))
        packet = Packet(Packet.ROUTING, self.addr, endpoint, self.lsa.to_json())
        self.broadcast("")
        self.config_routing_table()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        #   
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.broadcast("")
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        # 
        self.config_routing_table()
        return f"Routing Table: {self.routing_table}, LSA: {self.lsa.to_json()}"
